---
title: "内存管理"
date: 2020-09-02T02:27:00+08:00
draft: true
tags:
    - what
    - linux
    - kernel
    - memory
---

# 分段与分页基础

```plantuml
@startuml
start
:逻辑地址;
note right
在程序中使用的
由一个段和偏移量组成
end note
partition 分段机制 {
    :查询默认的或指定的段寄存器中的段选择子;
    :根据选择子到GDT或LDT中查询对应的段描述符;
    :获得段描述符中的基地址;
    :将基地址与偏移量相加获得线性地址;
}
:线性地址;
partition 分页机制 {
    :不同的处理器平台将线性地址划分成若干部分;
    :包括若干指示目录项的部分，一个指示页表项的部分，和offset;
    while (依次遍历目录各个部分)
        :根据cr3寄存器或上一部分查询到的地址确定要查询的页目录表或页表;
        :到上一步确定的页目录查询第{{线性地址该部分的值}}的项;
    endwhile
    :获得目标页表项所在的页表;
    :到目标页表中查询第{{线性地址指示页表项部分的值}}项，就是目标页表项;
    :获得页表项中的base地址，与线性地址中的offset部分组合，得到物理地址;
}
:物理地址;
stop
@enduml
```

## TLB

Translation lookaside buffer

用于缓存线性地址到物理地址的映射。

每个CPU都有一个，由操作系统决定什么时候失效。

## 硬件高速缓存

硬件高速缓存缓存了内存行，用于加速内存读写。

常说的L1 Cache就是一种硬件高速缓存。

每个CPU都有硬件高速缓存，**各个CPU之间的同步由硬件处理**。

像其他的缓存一样，写入的时候有两种策略：

- write back
- write through

# Linux中的分段

分段机制只在x86架构的平台上存在，Linux简单的使用分段机制。

Linux系统将逻辑地址与线性地址一一平铺的映射，即逻辑地址与线性地址是一致的。

实现上，最常用的有四个段：
- 用户数据段
- 用户代码段
- 内核数据段
- 内核代码段

其功能显然易见。

四个段从线性地址0开始映射，故逻辑地址与线性地址一致。

## GDT

Linux每个CPU有一个GDT，除了上述的四个段之外，有若干特殊功能的段以供使用。

### 任务状态段 TSS

每个CPU核心有一个TSS，有两个目的：

1. x86平台上，当从用户态切换到内核态时，CPU核心从TSS中获取并加载内核态堆栈。
1. 在用户态访问IO端口是，需要TSS中的IO许可权位图来做权限检查。

# Linux中的分页

Linux系统为兼容不同平台的分页机制，使用了四级分页模型：

- 页全局目录
- 页上级目录
- 页下级目录
- 页表

故线性地址看起来应该是这样的：

```plantuml
@startdot
digraph structs {
    node [shape=record];
    struct1 [label=" 页全局目录 | 页上级目录 | 页下级目录 | 页表 | 偏移量"];
}
@enddot
```

# 动态内存分配

## 页框与相关的数据结构

