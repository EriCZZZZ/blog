---
title: "中断与异常"
date: 2020-08-29T10:44:52+08:00
draft: true
tags:
    - what
    - linux
    - kernel
    - interrupt
    - exception
---

# 中断与异常的关系

刚开始看中断、异常相关的资料的时候，一直没有搞清楚两者的区别，导致一直是云里雾里、一头雾水，感觉资料怎么都是互相矛盾的啊。

其实在不同的资料里，各个名词的含义可能是不同的，特别是**中断**。

## 什么是中断？

先介绍一下广义上的中断。

引用下《深入理解Linux内核》对中断的定义：

> An interrupt is usually defined as an event that alters the sequence of instructions
executed by a processor. Such events correspond to electrical signals generated by
hardware circuits both inside and outside the CPU chip.

中断是一个事件，被用来改变处理器执行既定指令流程。我认为中断提供了实现异步的基础。

## 同步中断与异步中断

将**中断**分为**同步中断**和**异步中断**。

- 同步中断是CPU控制单元在执行每个指令时产生的。**同步**是因为这种中断一定是每个指令执行完后，才会被发出的。

- 与此相对的是异步中断，由外围设备产生，在任何时间都有可能产生。

## 异常是什么呢？

在Intel的手册中，将同步中断称为**异常**，将异步中断叫做中断。

## 小结

所以在看相关的资料的时候，第一步要做的就是，确定相关名词在资料中的含义。

# 中断、异常的分类

```plantuml
@startmindmap
* 中断
** 中断（异步中断）
*** 按是否能屏蔽
**** 不可屏蔽中断 一个中断是否是不可屏蔽的由CPU决定
**** 可屏蔽中断
*** 按中断产生方式
**** I/O中断
**** 时钟中断
**** 处理器间中断
** 异常（同步中断）
*** 处理器探测异常
****: 故障 fault
- 通常都是能修复，并返回正常执行。
- 发生时eip寄存器保存产生该故障的指令地址。;
****: 陷阱 trap
- 用于通知某条指令已经执行，通常用于调试。
- eip寄存器保存下一条要执行的指令地址。;
****: 异常终止 abort
- 用于报告严重错误。
- eip寄存器中无法精确保存引起该问题的指令地址。;
***: 编程异常
- 通常被称为软中断。
- 程序主动发出或溢出检查、地址出界检查失败时产生。;
@endmindmap
```

# 硬件上的

1. 可编程中断控制器 Programmable Interrupt Controller
1. I/O Advanced Programmable Interrupt Controller

# Linux上的处理

## 异常处理

```plantuml
@startuml
title 异常的处理

start
:把大部分寄存器的数据保存到内核堆栈;
if (发生在用户态还是内核态？) then (用户态)
else (内核态)
    if (是因为系统调用的参数不合法吗？) then (不合法)
    else (合法)
        :是内核bug导致的问题，进行kernel oops，终结进程;
        stop
    endif
endif
:具体的处理异常的函数;
:通过ret_from_exception()从流程中退出;
stop
@enduml
```

## 中断处理

### I/O中断处理

Linux根据响应中断要执行的操作分为三种：

- 紧急的 critical
- 非紧急的 noncritical
- 非紧急可延迟的 noncritical deferrable

```plantuml
@startuml
title I/O中断的处理

start
partition common_interrupt {
    partition 在内核堆栈中保存IRQ的值和寄存器的数据 {
        :SAVE_ALL 具体保存寄存器;
    }
    :movl %esp, %eax 保存栈顶地址到eax;
    partition "do_IRQ() 调用具体的处理函数" {
        if (sizeof(thread_union) == 4KB) then (Yes)
            :切换到硬中断请求栈;
        endif
        partition "__do_IRQ()" {
            :获取对应IRQ描述符的自旋锁;
            :调用PIC对象的ack方法;
            :设置相应的IRQ描述符的标志位:\n设置IRQ_PENDING\n清除IRQ_REPLAY IRQ_WAITING;
            if (IRQ描述符的状态 not in (IRQ_DISABLED, IRQ_INPROGRESS, 无中断服务例程)) then (需要处理中断)
                :设置IRQ描述符状态 IRQ_INPROGRESS;
                while (如果IRQ描述符状态有IRQ_PENDING) 
                    note right
                        如果重新出现IRQ_PENDING，
                        那么意味着在调用中断服务例程的时候，
                        发生了至少一次新中断。
                    end note
                    :清除IRQ_PENDING;
                    :释放锁;
                    :调用handle_IRQ_event处理中断;
                    :加锁;
                endwhile
                :清除IRQ描述符状态 IRQ_INPROGRESS;
            endif
            :调用PIC对象的end方法;
            :释放锁;
        }
        if (sizeof(thread_union) == 4KB && 之前切换到了新的堆栈) then (Yes)
            :切换回之前的堆栈;
        endif
        :ireq_exit();
    }
    partition 从中断返回 {
        :jmp ret_from_intr;
    }
}
:给PIC回应，来允许PIC发出接下里的中断;
:执行共享该IRQ的所有设备的中断服务例程;
:通过ret_from_intr()从流程中退出;
stop
@enduml
```
