---
title: "编译原理 第一章 笔记"
date: 2021-05-14T16:54:42+08:00
draft: false
tags:
    - compilers-book
    - book
order: 1
---

第一章介绍了将语言编译的整个流程与相关的工具集，
提出了若干概念。

{{% serial_index compilers-book %}}

# 编译工具流

1. 预处理器
1. 编译器
1. 汇编器
1. 链接器､加载器

# 编译器划分

## 简单划分

1. 前端 analysis
1. 后端 synthesis

## 详细一点的

1. lexical analyzer
1. synatx analyzer
1. semantic analyzer
1. intermediate code generator
1. machine-independent code optimizer
1. code generator
1. machine-dependent code optimizer

# 编译器流程

## 词法分析

词法分析器读入源程序的字符流，
分析后输出token流与符号表。

每个token表示源程序中的一个元素，
结构如下：

```plain
<abstract-name, symbol-table entry index>
```

## 语法分析

接受**词法分析器**产出的token流，
按照语法规则，
构建语法树。

## 语义分析

检查源程序是否符合语言的语义定义，
比如类型检查。

## 中间代码生成

接受语法树作为输入，生成中间代码，
比如三地址代码。

## 机器无关代码优化

## 目标代码生成

## 机器相关代码优化

# 编程语言基础

介绍了一系列学习编译原理需要了解的概念。

## 动态(dynamic)与静态(static)

当编译器在面对一个问题需要得到答案或得到一些信息时，
如果能够在编译期间确定，那么称为**静态**的；
反之，称为**动态**的。

举个例子，变量的作用域，
如果只需要读取源码就能得知变量的作用域，
称为是**静态作用域**，反之称为**动态作用域**。

## Environments和States

中译是**环境**和**状态**，
感觉不是特别有代表性。

两者描述了名称(name)､内存的位置和内存位置上存储的数据之间的映射关系。

**Environments**表示名称和内存位置之间的映射；
**States**表示内存位置与存储的数据之间的映射。

举个例子，对于嵌套的两个作用域，
相同名称(name)的两个变量，可以通过更换**环境**来完成切换。

## 静态作用域(static scope)、块结构(block structure)和显式访问控制

**块**是若干声明与语句的组合体。

C语言是静态作用域，一个名称的作用域隐含的取决于它声明的位置。

对于Java语言，使用了`private`/`public`/`protected`关键字来显示的控制名称的作用域。

## 动态作用域(dynamic scope)

正如前面对于**动态**的定义，**动态作用域**意味着要等到运行时才能决定一个名称的作用域。

常规的，比如宏，常规之外的有函数多态的实现。

## 参数传递机制与别名

调用函数时传递函数有**值调用**，**引用调用**和**名调用**。

对于**引用调用**，不同的变量指向了同一个数据，
会导致在一个变量上修改影响另一个变量的读取，这种称为**别名**。
