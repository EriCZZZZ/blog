---
title: "编译原理 第三章 笔记"
date: 2021-06-26T12:44:41+08:00
draft: true
tags:
    - compilers-book
    - book
order: 3
---

第三章在第二章的基础上，
介绍了构建**词法分析器**的技术。

<!--more-->

{{% serial_index compilers-book %}}

# 简介

**词法分析器**：
1. 读取源程序，
1. 处理空白字符与注释，
1. 维护源程序信息（用于错误提示等用途）
1. 和识别词素生成词法单元。

## 词法单元、模式与词素

- **词法单元** *(token)* 是由**词法单元名**与一系列相关的属性构成的一个数据结构实例。
- **词素** *(lexem)* 表示源程序中的一个具体的、与某种**词法单元**匹配的字符序列。
- **模式** *(pattern)* 用来描述**词法单元**可以匹配的**词素**的规则。

# 什么是语言

3.3.1依次给出若干定义来导出最后的**语言**的定义。

**字母表** *(alphablet)* 是一个有限的符号集合，
具体的，是一个语言源程序所包含的全部可能的字符。

一个**串** *(string)* 是一个具体的**字母表**中的符号构成的**有穷序列。

一个**语言**是一个在具体的**字母表**上产生的任意可数的**串**组成的集合。

# 定义语言的模式

3.3.3开始介绍了如何利用正则表达式定义**模式**。

# 根据模式识别词法单元 

3.4引入了**状态转换图** *(transition diagram)* 来识别词法单元。
核心思想为通过检查所有**模式**的前缀来确定当前读取到的字符序列的词法单元，
如果发生分歧，如不能唯一的确定，将会应用适当的策略（如最长匹配）来保证结果的唯一。

考虑到识别词法单元需要多次字符串匹配，
所以引入了KMP算法来提高匹配的效率。

# 词法分析器生成工具Lex

3.5介绍了词法分析器生成工具Lex。

# 手动构造词法分析器

3.6介绍了Lex的工作原理：**有穷自动机** *(finite automata)* 。

## 有穷自动机

本质上，**有穷自动机**是与**状态转换图**类似的图；
表现为一个**识别器** *(recognizer)* ，
能够对输入的**串**返回是或否。

**有穷自动机**根据任意节点是否存在一个**符号**匹配多个离开该节点的边分为
**不确定的有穷自动机** *(Nondeterministic Finite Automata, NFA)* 和
**确定的有穷自动机** *(Deterministic Finite Automata, NFA)* 。

# 参考
