---
title: "编译原理 第二章 笔记"
date: 2021-05-31T23:13:00+08:00
draft: true
tags:
    - compilers-book
    - book
order: 2
---

第二章通过实现一个将中序表达式转化为后续表达式的编译器，
简单介绍了编译器前端实现需要的技术。

<!--more-->

{{% serial_index compilers-book %}}

# TL;DR

TBD

# 2.1 引言

编译器前端又称**分析**阶段，
接受代码文件作为输入，
通过词法分析、语法分析，
最后生成被称为中间代码的内部表示。

## **分析**：**语法**与**语义**

**分析**阶段的工作围绕语言的**语法**和**语义**展开：

- **语法**定义了语言的正确形式，可以且通常由**上下文无关文法** *(context-free grammar)* 来描述。
- **语义**表示了语言的含义，相较于**语法**，**语义**的描述难度高出很多，故采取非形式化描述与启发式描述来体现**语义**。

## **语法制导翻译**

**上下文无关文法**除了可以定义**语法**，
还可以用来帮助、引导翻译的进行。

**语法制导翻译**就是一种这样的、面向文法 *(grammar-oriented)* 的编译技术。

## 编译器前端模型

通常来说，一个编译器的前端：

1. 接受源代码字符流作为入参，通过词法分析，生成符号表，输出**词法单元**流。
1. 对**词法单元**流进行语法分析和语义分析，
产出**抽象语法树** *(AST)* 或简称**语法树** *(syntax tree)*。
1. 中间代码生成器根据**语法树**生成三地址代码（一种中间代码的形式）。

# 2.2 语法定义

## 首先给出了语法定义的若干定义

1. **产生式**

    对于编程语言中常见的`if-else`结构，可以描述为：

    $$
    stmt \to \textbf{if} ( expr )\ stmt\ \textbf{else}\ stmt
    $$

    符合直觉的，$stmt$是一个程序代码块。而这样的规则被称为**产生式**。

    进一步的，对于**产生式**左侧的$stmt$，称为**产生式头部**或**左部**；
    对于右侧的$\textbf{if} ( expr )\ stmt\ \textbf{else}\ stmt$，称为**产生式体**或**右部**。

1. **终结符**与**非终结符**

    像关键字$\textbf{if}$或词法元素$($这种，被称为**终结符**。
    反之，像$stmt$这种表示**终结符**串的符号称为**非终结符**。

## 文法的定义

*在编译原理这本书中，文法在某些时候指的是**上下文无关文法**。*

一个**上下文无关文法**由四个元素组成：

1. **终结符**集合
1. **非终结符**集合
1. **产生式**集合
1. 指定一个**非终结符**为**开始**符号

## 推导、语法分析与语法分析树

**语法分析** *(parsing)* 的任务是接受终结符号串作为参数，从**文法**的**开始符号**开始，
寻找**推导**出该终结符号串的方法；如果无法找到，那么就抛出一个语法错误。

符合直觉的，**推导** *(derivation)* 指的是从**文法**定义的**开始**符号开始，
不断用**非终结符**的某一**产生式体**来替换**产生式体**中该**非终结符**。

**语法分析树** *(parse tree)* 是推导过程的图形化展示：
1. 根节点表示**开始**符号
1. 每个子节点表示父节点的产生式体中的终结符或非终结符，有序
1. （可以得出）每个叶子节点均表示终结符，树内部的节点，均表示非终结符

## 文法的二义性

对于给定的一个文法，
如果可以有多个不同的语法分析树产生同一个终结符号串，
那么称这个文法有**二义性** *(ambiguous)*。

在文法的设计上，我们通过调整文法避免产生**二义性**或在使用文法时附加可以消除**二义性**的规则。

举个简单的例子，
对于表达式：

$$
2-5+9
$$

如果文法定义为：

$$
stmt \to stmt - stmt\ |\ stmt + stmt\ |\ digital
$$

基于优先匹配表达式左侧或右侧，可以构造出两种语法分析树：

1. $(2-5)+9$
1. $2-(5+9)$

这个例子的一个问题是二义性，
另一个问题是第二种的结合是错误的，
进而引出了运算符的结合性问题。

## 运算符的结合性、优先级

对于`1 + 5 + 2`中的`5`来说，左右都是运算符`+`，
**运算符的结合性**来决定它应该和哪个`+`结合。
由于`+`是**左结合**的，意味着`1+5`是优先的选择。
**右结合**的符号举个例子有指数符号、C语言中的赋值符号`=`。

表达式中经常会出现一个运算分量左右为不同的运算符的情况，
如`1 + 5 * 2`。**运算符的优先级**决定了`5`优先与哪个运算符结合，
因为`*`的优先级比`+`高，这里会优先选择`5 * 2`。

我理解**结合性**解决了同符号之间的二义性问题，
**优先级**则是解决了不同符号之间的二义性问题。

### 一种支持运算符优先级和结合性的文法

首先构造**优先级表**，每一行的运算符拥有相同的**结合性**和**优先级**：

```plain
左结合：+ -
左结合：* /
```

为每一个层级创建一个非终结符：表示加减的$expr$和表示乘除的$term$。
为运算分量创建一个非终结符：$factor$。

$$
expr \to expr + term \ |\ expr - term\ |\ term
$$
$$
term \to term * factor\ |\ term / factor\ |\ factor
$$
$$
factor \to \textbf{digit}\ |\ (expr)
$$

可以看到$factor$会优先生成高优先级层级的非终结符$term$，
然后由$term$进一步的生成$expr$，
这种方式可以支持若干层优先级的构建。

# 2.3 语法制导翻译

这篇文档解释的比较到位：
[对于语法制导翻译的一些介绍](https://web.stanford.edu/class/archive/cs/cs143/cs143.1128/handouts/160%20Syntax-Directed%20Translation.pdf)。

**语法制导翻译** *(syntax-directed translation)* 是一种实现编译器的思路。

其核心思想是围绕语法定义，通过解析语法来驱动整个编译的完成。

**语法制导翻译**可以通过向语法符号附加规则､定义､需要执行的代码（称为动作 *(Action)*）等信息来实现。

## 两个与**语法制导翻译**有关的概念

### 属性 *(Attribute)*

这里的**属性**的含义与常规的认知一致，
表示语言中的结构关联的属性，
语法符号用来表示语言中的结构，所以也可以说是语法符号拥有的属性。

一些例子，变量的类型，整型的值，函数的名称都可以是**属性**。

属性分为**继承属性**和**综合属性**，
两者由产生的来源决定：
如果由产生式决定，
那么称为**综合属性**；
如果由父节点或兄弟节点决定，
那么称为**继承属性**。

### 翻译方案 *(translation schema)*

**翻译方案**指的是将程序片段附加到文法符号的产生式的这种方法。

这些程序片段会被语法分析驱动的过程中依次调用，产生输出，
组合之后就是翻译的结果。

**翻译方案**由两种思路，
一种是修改**属性**，来拼接结果；
另一种是直接输出结果。

# 2.4 语法分析

**语法分析**是根据定义的文法，寻找如何生成输入的**词法单元**流的过程。

这一节介绍了一种语法分析的方法**递归下降** *(recursive descent)*。
**递归下降**方法不光可以构建**语法分析器**，也可以用来构建**语法制导翻译器**。

大部分语法分析方法根据语法分析树节点的构造顺序属于两个分类：
**自顶向下**与**自顶向上**。

两者有各自的优势：
- **自顶向下**类型便于人工构造高效的语法分析器。
- **自顶向上**类型能够支持更加复杂的语法，
所以生成编译器的工具通常使用这种策略。

## 自顶向下的语法分析方法

**自顶向下**方式生成一个语法分析树从根节点开始，
递归的执行如下流程：

1. 在表示非终结符$A$的节点$N$上，**选择一个产生式**，
根据产生式体的语法符号，依次构建节点$N$的子节点。
1. 寻找下一个需要构建子节点的节点
（，通常是目前的语法分析树的最左侧、未展开的、表示非终结符的节点），
循环这个过程。

## 递归下降分析法(recursive-descent parsing)与预测分析法(Predictive Parsing)

**递归下降分析法**是一种**自顶向下**的语法分析方法，
通过一组递归的过程来进行分析。
每个终结符都有自己的处理过程，
**递归下降分析法**通过递归的调用这些过程，
来处理输入。

对于一些设计的语法，
完成前述的流程只需要一次自左向右的扫描，
原因在于 **【选择一个产生式】** 时，不需要“试错”，
这种情况是**递归下降分析法**的一种简单形式，
称为**预测分析法**。

为了说明这种情况，
首先给出**前瞻符号** *(lookahead symbol)* 的概念，
对于语法分析中，当前正在被扫描的终结符，称为**前瞻符号**。

如果**前瞻符号**能够唯一确定需要选择的产生式，
那么就不需要回溯，也就是说，只需要一次扫描就能完成语法分析。

自然的，引出概念$FIRST(\alpha)$：
对于一个语法符号$\alpha$，
$FIRST(\alpha)$表示$\alpha$能够生成的若干终结符串的串首的终结符的集合。
根据定义，终结符的$FIRST$是它自身；
非终结符的$FIRST$是它若干产生式的首个语法符号的$FIRST$的并集。

如果语法定义的所有非终结符的$FIRST$两两均不相交，
那么就可以使用**预测分析法**来构建对应的语法分析器。

## 左递归问题 left-recursion

**递归下降**语法分析器在分析特定的语法时，可能进入无限循环。

比如如下形式的**左递归**产生式：

$$
expr \to expr\ +\ term
$$

可以通过一些转换来消除左递归。

# 2.5 简单表达式的翻译器

[一个基于go的实现](https://github.com/er1c-zh/blog/blob/d61156c9f935e6d79a72e9c653e84f5c95d92a85/practice/compilers/simple_converter/main.go)

## 抽象语法树与语法解析树

> 抽象语法树 abstract syntax tree
> 语法解析树 parse tree

AST的节点表示程序结构，
语法解析树的节点表示终结符与非终结符。

## 对于尾递归的简化

对于语法制导翻译来说，非终结符有自己的**过程** *(procedure)*，
对于其中有**尾递归**类型的递归调用时，
可以转换为循环简化实现。

# 2.6 词法分析

# 参考

- [对于语法制导翻译的一些介绍](https://web.stanford.edu/class/archive/cs/cs143/cs143.1128/handouts/160%20Syntax-Directed%20Translation.pdf)
