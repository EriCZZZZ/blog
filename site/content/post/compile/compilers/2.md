---
title: "编译原理 第二章笔记"
date: 2021-05-31T23:13:00+08:00
draft: true
tags:
    - compilers-book
    - book
order: 2
---

第二章通过实现一个将中序表达式转化为后续表达式的编译器，
简单介绍了编译器前端实现需要的技术。

<!--more-->

{{% serial_index compilers-book %}}

# TL;DR

TBD

# 2.1 引言

编译器前端又称**分析**阶段，
接受代码文件作为输入，
通过词法分析、语法分析，
最后生成被称为中间代码的内部表示。

## **分析**：**语法**与**语义**

**分析**阶段的工作围绕语言的**语法**和**语义**展开：

- **语法**定义了语言的正确形式，可以且通常由**上下文无关文法** *(context-free grammar)* 来描述。
- **语义**表示了语言的含义，相较于**语法**，**语义**的描述难度高出很多，故采取非形式化描述与启发式描述来体现**语义**。

## **语法制导翻译**

**上下文无关文法**除了可以定义**语法**，
还可以用来帮助、引导翻译的进行。

**语法制导翻译**就是一种这样的、面向文法 *(grammar-oriented)* 的编译技术。

## 编译器前端模型

通常来说，一个编译器的前端：

1. 接受源代码字符流作为入参，通过词法分析，生成符号表，输出**词法单元**流。
1. 对**词法单元**流进行语法分析和语义分析，
产出**抽象语法树** *(AST)* 或简称**语法树** *(syntax tree)*。
1. 中间代码生成器根据**语法分析树**生成三地址代码（一种中间代码的形式）。

# 2.2 语法定义

## 首先给出了语法定义的若干定义

1. **产生式**

    对于编程语言中常见的`if-else`结构，可以描述为：

    $$
    stmt \to \textbf{if} ( expr )\ stmt\ \textbf{else}\ stmt
    $$

    符合直觉的，$stmt$是一个程序代码块。而这样的规则被称为**产生式**。

    进一步的，对于**产生式**左侧的$stmt$，称为**产生式头部**或**左部**；
    对于右侧的$\textbf{if} ( expr )\ stmt\ \textbf{else}\ stmt$，称为**产生式体**或**右部**。

1. **终结符**与**非终结符**

    像关键字$\textbf{if}$或词法元素$($这种，被称为**终结符**。
    反之，像$stmt$这种表示**终结符**串的符号称为**非终结符**。

## 文法的定义

*在编译原理这本书中，文法在某些时候指的是**上下文无关文法**。*

一个**上下文无关文法**由四个元素组成：

1. **终结符**集合
1. **非终结符**集合
1. **产生式**集合
1. 指定一个**非终结符**为**开始**符号

## 推导、语法分析与语法分析树

**语法分析** *(parsing)* 的任务是接受终结符号串作为参数，从**文法**的**开始符号**开始，
寻找**推导**出该终结符号串的方法；如果无法找到，那么就抛出一个语法错误。

符合直觉的，**推导** *(derivation)* 指的是从**文法**定义的**开始**符号开始，
不断用**非终结符**的某一**产生式体**来替换**产生式体**中该**非终结符**。

**语法分析树** *(parse tree)* 是推导过程的图形化展示：
1. 根节点表示**开始**符号
1. 每个子节点表示父节点的产生式体中的终结符或非终结符，有序
1. （可以得出）每个叶子节点均表示终结符，树内部的节点，均表示非终结符

## 文法的二义性

对于给定的一个文法，
如果可以有多个不同的语法分析树产生同一个终结符号串，
那么称这个文法有**二义性** *(ambiguous)*。

在文法的设计上，我们通过调整文法避免产生**二义性**或在使用文法时附加可以消除**二义性**的规则。

举个简单的例子，
对于表达式：

$$
2-5+9
$$

如果文法定义为：

$$
stmt \to stmt - stmt\ |\ stmt + stmt\ |\ digital
$$

基于优先匹配表达式左侧或右侧，可以构造出两种语法分析树：

1. $(2-5)+9$
1. $2-(5+9)$

这个例子的一个问题是二义性，
另一个问题是第二种的结合是错误的，
进而引出了运算符的结合性问题。

## 运算符的结合性、优先级

对于`1 + 5 + 2`中的`5`来说，左右都是运算符`+`，
**运算符的结合性**来决定它应该和哪个`+`结合。
由于`+`是**左结合**的，意味着`1+5`是优先的选择。
**右结合**的符号举个例子有指数符号、C语言中的赋值符号`=`。

表达式中经常会出现一个运算分量左右为不同的运算符的情况，
如`1 + 5 * 2`。**运算符的优先级**决定了`5`优先与哪个运算符结合，
因为`*`的优先级比`+`高，这里会优先选择`5 * 2`。

我理解**结合性**解决了同符号之间的二义性问题，
**优先级**则是解决了不同符号之间的二义性问题。

### 一种支持运算符优先级和结合性的文法

首先构造**优先级表**，每一行的运算符拥有相同的**结合性**和**优先级**：

```plain
左结合：+ -
左结合：* /
```

为每一个层级创建一个非终结符：表示加减的$expr$和表示乘除的$term$。
为运算分量创建一个非终结符：$factor$。

$$
expr \to expr + term \ |\ expr - term\ |\ term
$$
$$
term \to term * factor\ |\ term / factor\ |\ factor
$$
$$
factor \to \textbf{digit}\ |\ (expr)
$$

可以看到$factor$会优先生成高优先级层级的非终结符$term$，
然后由$term$进一步的生成$expr$，
这种方式可以支持若干层优先级的构建。

# 2.3 语法制导翻译

这篇文档解释的比较到位：
[对于语法制导翻译的一些介绍](https://web.stanford.edu/class/archive/cs/cs143/cs143.1128/handouts/160%20Syntax-Directed%20Translation.pdf)。

**语法制导翻译** *(syntax-directed translation)* 是一种实现编译器的思路。

其核心思想是围绕语法定义，通过解析语法来驱动整个编译的完成。

**语法制导翻译**可以通过向语法符号附加规则､定义､需要执行的代码（称为动作 *(Action)*）等信息来实现。

## 两个与**语法制导翻译**有关的概念

### 属性 *(Attribute)*

这里的**属性**的含义与常规的认知一致，
表示语言中的结构关联的属性，
语法符号用来表示语言中的结构，所以也可以说是语法符号拥有的属性。

一些例子，变量的类型，整型的值，函数的名称都可以是**属性**。

属性分为**继承属性**和**综合属性**，
两者由产生的来源决定：
如果由产生式决定，
那么称为**综合属性**；
如果由父节点或兄弟节点决定，
那么称为**继承属性**。

### 翻译方案 *(translation schema)*

**翻译方案**指的是将程序片段附加到文法符号的产生式的这种方法。

这些程序片段会被语法分析驱动的过程中依次调用，产生输出，
组合之后就是翻译的结果。

**翻译方案**由两种思路，
一种是修改**属性**，来拼接结果；
另一种是直接输出结果。

# 2.4 语法分析

**语法分析**是根据定义的文法，寻找如何生成输入的**词法单元**流的过程。

这一节介绍了一种语法分析的方法**递归下降** *(recursive descent)*。
**递归下降**方法不光可以构建**语法分析器**，也可以用来构建**语法制导翻译器**。

# 参考

- [对于语法制导翻译的一些介绍](https://web.stanford.edu/class/archive/cs/cs143/cs143.1128/handouts/160%20Syntax-Directed%20Translation.pdf)
