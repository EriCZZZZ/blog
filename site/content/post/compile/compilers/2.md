---
title: "编译原理 第二章 笔记"
date: 2021-05-31T23:13:00+08:00
draft: true
tags:
    - compilers-book
    - book
order: 2
---

第二章通过实现一个将中序表达式转化为后续表达式的编译器，
简单介绍了编译器前端实现需要的技术。

<!--more-->

{{% serial_index compilers-book %}}

# TL;DR

第二章从实现一个解析简单的四则运算的语法分析器开始，
逐步引出了词法分析、语法分析、语义分析和生成三代码地址。
在后半部分慢慢扩展了语法，并提出了问题和一些初步的方案。

# 2.1 引言

编译器前端又称**分析**阶段，
接受代码文件作为输入，
通过词法分析、语法分析，
最后生成被称为中间代码的内部表示。

## **分析**：**语法**与**语义**

**分析**阶段的工作围绕语言的**语法**和**语义**展开：

- **语法**定义了语言的正确形式，可以且通常由**上下文无关文法** *(context-free grammar)* 来描述。
- **语义**表示了语言的含义，相较于**语法**，**语义**的描述难度高出很多，故采取非形式化描述与启发式描述来体现**语义**。

## **语法制导翻译**

**上下文无关文法**除了可以定义**语法**，
还可以用来帮助、引导翻译的进行。

**语法制导翻译**就是一种这样的、面向文法 *(grammar-oriented)* 的编译技术。

## 编译器前端模型

通常来说，一个编译器的前端：

1. 接受源代码字符流作为入参，通过词法分析，生成符号表，输出**词法单元**流。
1. 对**词法单元**流进行语法分析和语义分析，
产出**抽象语法树** *(AST)* 或简称**语法树** *(syntax tree)*。
1. 中间代码生成器根据**语法树**生成三地址代码（一种中间代码的形式）。

# 2.2 语法定义

## 首先给出了语法定义的若干定义

1. **产生式**

    对于编程语言中常见的`if-else`结构，可以描述为：

    $$
    stmt \to \textbf{if} ( expr )\ stmt\ \textbf{else}\ stmt
    $$

    符合直觉的，$stmt$是一个程序代码块。而这样的规则被称为**产生式**。

    进一步的，对于**产生式**左侧的$stmt$，称为**产生式头部**或**左部**；
    对于右侧的$\textbf{if} ( expr )\ stmt\ \textbf{else}\ stmt$，称为**产生式体**或**右部**。

1. **终结符**与**非终结符**

    像关键字$\textbf{if}$或词法元素$($这种，被称为**终结符**。
    反之，像$stmt$这种表示**终结符**串的符号称为**非终结符**。

## 文法的定义

*在编译原理这本书中，文法在某些时候指的是**上下文无关文法**。*

一个**上下文无关文法**由四个元素组成：

1. **终结符**集合
1. **非终结符**集合
1. **产生式**集合
1. 指定一个**非终结符**为**开始**符号

## 推导、语法分析与语法分析树

**语法分析** *(parsing)* 的任务是接受终结符号串作为参数，从**文法**的**开始符号**开始，
寻找**推导**出该终结符号串的方法；如果无法找到，那么就抛出一个语法错误。

符合直觉的，**推导** *(derivation)* 指的是从**文法**定义的**开始**符号开始，
不断用**非终结符**的某一**产生式体**来替换**产生式体**中该**非终结符**。

**语法分析树** *(parse tree)* 是推导过程的图形化展示：
1. 根节点表示**开始**符号
1. 每个子节点表示父节点的产生式体中的终结符或非终结符，有序
1. （可以得出）每个叶子节点均表示终结符，树内部的节点，均表示非终结符

## 文法的二义性

对于给定的一个文法，
如果可以有多个不同的语法分析树产生同一个终结符号串，
那么称这个文法有**二义性** *(ambiguous)*。

在文法的设计上，我们通过调整文法避免产生**二义性**或在使用文法时附加可以消除**二义性**的规则。

举个简单的例子，
对于表达式：

$$
2-5+9
$$

如果文法定义为：

$$
stmt \to stmt - stmt\ |\ stmt + stmt\ |\ digital
$$

基于优先匹配表达式左侧或右侧，可以构造出两种语法分析树：

1. $(2-5)+9$
1. $2-(5+9)$

这个例子的一个问题是二义性，
另一个问题是第二种的结合是错误的，
进而引出了运算符的结合性问题。

## 运算符的结合性、优先级

对于`1 + 5 + 2`中的`5`来说，左右都是运算符`+`，
**运算符的结合性**来决定它应该和哪个`+`结合。
由于`+`是**左结合**的，意味着`1+5`是优先的选择。
**右结合**的符号举个例子有指数符号、C语言中的赋值符号`=`。

表达式中经常会出现一个运算分量左右为不同的运算符的情况，
如`1 + 5 * 2`。**运算符的优先级**决定了`5`优先与哪个运算符结合，
因为`*`的优先级比`+`高，这里会优先选择`5 * 2`。

我理解**结合性**解决了同符号之间的二义性问题，
**优先级**则是解决了不同符号之间的二义性问题。

### 一种支持运算符优先级和结合性的文法

首先构造**优先级表**，每一行的运算符拥有相同的**结合性**和**优先级**：

```plain
左结合：+ -
左结合：* /
```

为每一个层级创建一个非终结符：表示加减的$expr$和表示乘除的$term$。
为运算分量创建一个非终结符：$factor$。

$$
expr \to expr + term \ |\ expr - term\ |\ term
$$
$$
term \to term * factor\ |\ term / factor\ |\ factor
$$
$$
factor \to \textbf{digit}\ |\ (expr)
$$

可以看到$factor$会优先生成高优先级层级的非终结符$term$，
然后由$term$进一步的生成$expr$，
这种方式可以支持若干层优先级的构建。

# 2.3 语法制导翻译

这篇文档解释的比较到位：
[对于语法制导翻译的一些介绍](https://web.stanford.edu/class/archive/cs/cs143/cs143.1128/handouts/160%20Syntax-Directed%20Translation.pdf)。

**语法制导翻译** *(syntax-directed translation)* 是一种实现编译器的思路。

其核心思想是围绕语法定义，通过解析语法来驱动整个编译的完成。

**语法制导翻译**可以通过向语法符号附加规则､定义､需要执行的代码（称为动作 *(Action)*）等信息来实现。

## 两个与**语法制导翻译**有关的概念

### 属性 *(Attribute)*

这里的**属性**的含义与常规的认知一致，
表示语言中的结构关联的属性，
语法符号用来表示语言中的结构，所以也可以说是语法符号拥有的属性。

一些例子，变量的类型，整型的值，函数的名称都可以是**属性**。

属性分为**继承属性**和**综合属性**，
两者由产生的来源决定：
如果由产生式决定，
那么称为**综合属性**；
如果由父节点或兄弟节点决定，
那么称为**继承属性**。

### 翻译方案 *(translation schema)*

**翻译方案**指的是将程序片段附加到文法符号的产生式的这种方法。

这些程序片段会被语法分析驱动的过程中依次调用，产生输出，
组合之后就是翻译的结果。

**翻译方案**由两种思路，
一种是修改**属性**，来拼接结果；
另一种是直接输出结果。

# 2.4 语法分析

**语法分析**是根据定义的文法，寻找如何生成输入的**词法单元**流的过程。

这一节介绍了一种语法分析的方法**递归下降** *(recursive descent)*。
**递归下降**方法不光可以构建**语法分析器**，也可以用来构建**语法制导翻译器**。

大部分语法分析方法根据语法分析树节点的构造顺序属于两个分类：
**自顶向下**与**自顶向上**。

两者有各自的优势：
- **自顶向下**类型便于人工构造高效的语法分析器。
- **自顶向上**类型能够支持更加复杂的语法，
所以生成编译器的工具通常使用这种策略。

## 自顶向下的语法分析方法

**自顶向下**方式生成一个语法分析树从根节点开始，
递归的执行如下流程：

1. 在表示非终结符$A$的节点$N$上，**选择一个产生式**，
根据产生式体的语法符号，依次构建节点$N$的子节点。
1. 寻找下一个需要构建子节点的节点
（，通常是目前的语法分析树的最左侧、未展开的、表示非终结符的节点），
循环这个过程。

## 递归下降分析法(recursive-descent parsing)与预测分析法(Predictive Parsing)

**递归下降分析法**是一种**自顶向下**的语法分析方法，
通过一组递归的过程来进行分析。
每个终结符都有自己的处理过程，
**递归下降分析法**通过递归的调用这些过程，
来处理输入。

对于一些设计的语法，
完成前述的流程只需要一次自左向右的扫描，
原因在于 **【选择一个产生式】** 时，不需要“试错”，
这种情况是**递归下降分析法**的一种简单形式，
称为**预测分析法**。

为了说明这种情况，
首先给出**前瞻符号** *(lookahead symbol)* 的概念，
对于语法分析中，当前正在被扫描的终结符，称为**前瞻符号**。

如果**前瞻符号**能够唯一确定需要选择的产生式，
那么就不需要回溯，也就是说，只需要一次扫描就能完成语法分析。

自然的，引出概念$FIRST(\alpha)$：
对于一个语法符号$\alpha$，
$FIRST(\alpha)$表示$\alpha$能够生成的若干终结符串的串首的终结符的集合。
根据定义，终结符的$FIRST$是它自身；
非终结符的$FIRST$是它若干产生式的首个语法符号的$FIRST$的并集。

如果语法定义的所有非终结符的$FIRST$两两均不相交，
那么就可以使用**预测分析法**来构建对应的语法分析器。

## 左递归问题 left-recursion

**递归下降**语法分析器在分析特定的语法时，可能进入无限循环。

比如如下形式的**左递归**产生式：

$$
expr \to expr\ +\ term
$$

可以通过一些转换来消除左递归。

# 2.5 简单表达式的翻译器

[一个基于go的实现](https://github.com/er1c-zh/blog/blob/d61156c9f935e6d79a72e9c653e84f5c95d92a85/practice/compilers/simple_converter/main.go)

## 抽象语法树与语法解析树

> 抽象语法树 abstract syntax tree
> 语法解析树 parse tree

AST的节点表示程序结构，
语法解析树的节点表示终结符与非终结符。

## 对于尾递归的简化

对于语法制导翻译来说，非终结符有自己的**过程** *(procedure)*，
对于其中有**尾递归**类型的递归调用时，
可以转换为循环简化实现。

# 2.6 词法分析

词法分析用来将字符流分割为**词法单元**，
构成**词法单元**的字符序列称为**词素** *(lexme)*。

本节面向简单的加减乘除表达式介绍了词法分析需要做的工作。

## 去除空格

对于当前没有需要保留空字符的情况，直接采取跳过空字符的策略即可。

## 常量

如果遇到了数字，
通过**预读**确定下一个字符，
如果是数字就继续读取，否则停止。

## 标识符与关键字的处理

某些字符串用来表示程序的结构，称为**关键字** *(keyword)*；
或者为函数、变量等命名，称为标识符。

对于一个字符序列，需要区分是构成了标识符还是关键字，
这个工作可以通过**保留字** *(reserved)* 来解决。

本节的词法分析器使用一个字符串为key、**引用** *(reference)*为value的表格来解决两个问题：

1. 将同样的字符串使用同一个**引用**来表示，便于后续的操作。
1. 在初始化时写入**保留字**，完成**关键字**的区分。

# 2.7 符号表

**符号表**是用来存储源文件信息的数据结构。

对于不同的作用域，可能会有相同名称的标识符，
这种情况可以为每个域构建一个**符号表**来解决。
一是可以以堆栈的形式不断的为之前的**符号表**打patch的形式；
另一种是可以维持多个**符号表**之间的变更，
在切换**符号表**时，应用或恢复这些变更。

# 2.8 中间代码生成

中间代码主要有两种形式：
1. 树：**语法分析树**和**抽象语法树**
1. 线性表示：比如**三地址代码**

## 构造抽象语法树

最基本的，
为每一种**语法结构** *(statement construct)* 
在**语法定义** *(abstract syntax)* 中定义一个**操作符** *(operator)* 。
随后，实现上为每一个**操作符**定义一个`Node`的子类，
这意味着这些**操作符**的类会被用来构造抽象语法树。
特别的，有一些特别类型的子类用来表示某些非终结符，
如`Seq`表示`Stmts`，是`Stmt`的子类，而两者都继承了`Node`的子类。
对于多个语句构成的语法块，
在**语法树**中并无特别的区别，
可以通过构造一个**语法块**的类来处理。

## 静态检查

静态检查包括**语法检查**和**类型检查**，
其中，**类型检查**会检查每个操作符的操作数数量和类型是否正确。

- 左值右值检查
- 类型检查 *Type Checking*

    类型检查帮助确定一个程序结构的类型是否符合上下文的需要。
    引出两个概念**自动类型转换** *(coercion)* 和 **重载** *(overloading)* 。
    
## 三地址代码 Three-Address Code

**三地址代码**是形如：

$$
x = y\ \textbf{op}\ z
$$

的表达式。
其中，$x,y,z$是名称、常量或编译器生成的临时变量；
$\textbf{op}$表示**操作符** *(operator)*。

### 语句 *(Statements)* 的翻译

翻译语句比较重要的一点是控制流的跳转，
可以通过定义一种**三地址代码**来处理：

$$
ifFalse\ x\ goto\ after
$$

### 表达式 *(Expressions)* 的翻译

除去控制代码流转的部分，大部分便是**表达式**。
**表达式**的翻译包括二目运算符、数组的访问和赋值以及包含常量的计算。

对于**表达式**基本的逻辑是转换成两个操作数的运算，
有一些情况比较特别：

1. 对于常量或标识符，不需要做特殊的处理。
1. 需要区分左值右值。
    1. 普通的标识符没有特别的区别。
    1. 对于数组，分别生成`Access`和`Assign`两种节点，对应数组元素的左值和右值。


# 参考

- [对于语法制导翻译的一些介绍](https://web.stanford.edu/class/archive/cs/cs143/cs143.1128/handouts/160%20Syntax-Directed%20Translation.pdf)
